## Redirect & Forward
### Redirect
![image](https://user-images.githubusercontent.com/122864238/230334225-14ed490b-05d8-4b3e-9c44-399032a5079e.png)

redirect는 서버에서 클라이언트에서 요청한 URL에 대한 응답에서 다른 URL로 재접속하라고 
명령을 보내는 것으로 Re-Direct는 URL을 다시 가리킨다는 뜻을 가져 클라이언트는 해당 
URL로 다시 요청하게 된다. 리다이렉트가 일어나면 URL 주소가 바뀌면서 다시 접속되게 된다.               
->웹 브라우저는 서버에서 Redirect를 하라는 응답코드인 300번대 코드가 오게되면 
redirect를 해야되는 URL로 다시 요청을 보내는 역할을 한다. 

##### 리다이렉트는 클라이언트의 요청에 의해 서버의 DB에 변화가 생기는 작업에 사용된다.        
##### ->예를들어 DB의 유저 테이블을 변경하는 회원가입과 같은 경우에는 리다이렉트가 사용되어야 요청을 중복해서 보내는 것을 방지할 수 있다.

### Forward
![image](https://user-images.githubusercontent.com/122864238/230334301-161e5f9b-3176-4c9e-8088-7d4d0eeb6644.png)

클라이언트가 한 번 더 요청을 보내도록 하는 리다이렉트와 다르게 포워드는 서버 내부에서 
일어나는 호출로 클라이언트의 URL에 대한 요청이 들어오면 해당 URL이 다른 URL로 포워딩 
된 것이 확인되었을 경우 서버에서 포워딩된 URL의 리소스를 확인하여 클라이언트에 
응답한다.                   
->포워딩이 일어나면 클라이언트에서는 아무런 동작을 하지 않으며, 모든 동작을 서버에서 
처리하기 때문에 클라이언트(웹브라우저)에서 요청한 URL과 요청정보는 바뀌지 않는다. 

##### 포워드는 특정 URL에 대해 외부에 공개되지 말아야하는 부분을 가리는데 사용하거나 조회를 위해 사용된다.

### Redirect vs Forward     

사용자의 요청 정보가 바뀌어버리는 리다이렉트와 요청 정보는 그대로 유지한 채 서버 
내부의 동작만 바뀌는 포워드는 적절히 사용되어야 한다.

1) redirect는 URL에 변화가 생기지만 forward는 URL에 변화가 생기지 않는다.
2) forward는 객체를 재사용하지만 redirect는 객체를 재사용하지 않는다.
시스템(session, DB)에 변화가 생기는 요청(로그인, 회원가입, 글쓰기)의 경우 
redirect 방식으로 응답하는 것이 바람직하고 시스템에 변화가 생기지 않는 단순 조회
(리스트보기, 검색)의 경우 forward방식으로 응답하는 것이 좋다.

특정 URL 접속 시 리다이렉트 또는 포워드가 일어나게 되면 작업 중인 페이지가 전환되는데 
리다이렉트는 페이지 전환 주체가 클라이언트이고 포워드는 페이지 전환 주체가 서버이다. 
클라이언트가 주체가 되어 페이지를 전환하는 방법은 접속한 URL이 아닌 다른 URL로 직접 
접속하는 방법밖에 없지만 반대로 서버가 전환 주체가 되면 URL 주소가 바뀌지 않고도 서버 
내부의 동작을 통해 다른 응답을 클라이언트에 줄 수 있게된다.

#### 스프링의 경우 /WEB-INF에 있는 view에 대한 정보들이 외부에 직접 공개되지 말아야 할 때 내부에서 포워딩을 통해 /WEB-INF 경로를 가리키도록 한다. 



## 세션 & 쿠키
HTTP 프로토콜의 특성이자 약점을 보완하기 위해 코키 또는 세션을 사용하는데 HTTP 
프로토콜 환경은 connectionless, stateless한 특성을 가지기 때문에 서버는 클라이언트가 
누구인지 매번 확인해야한다.         
->이 특성을 보완하기 위해서 쿠키와 세션을 사용하게 된다.
### connectionless
클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어버리는 특징으로 HTTP는 먼저 
클라이언트가 request를 서버에 보내면 서버는 클라이언트에게 요청에 맞는 response를 
보내고 접속을 끊는 특성이 있다.          
->헤더에 keep-alive라는 값을 줘서 커넥션을 재활용하는데 HTTP1.1에서는 이것이 디폴트이다.
### stateless
통신이 끝나면 상태를 유지하지 않는 특징으로 연결을 끊는 순간 클라이언트와 서버의 통신이 
끝나며 상태 정보는 유지하지 않는 특성이 있다.           
->쿠키와 세션은 connectionless와 stateless를 해결하기 위해 사용하는데 쿠키와 세션을 
사용하지 않으면 쇼핑몰에서 옷을 구매하려고 로그인을 했음에도 페이지를 이동할 때마다 
계속 로그인을 해야한다. 쿠키와 세션을 사용했을 경우 한 번 로그인을 하면 어떻나 방식에 의해서 
그 사용자에 대한 인증을 유지하게 된다.

## 쿠키
![image](https://user-images.githubusercontent.com/122864238/230334481-5f81b0f4-d7b7-4497-897b-20113b67ab06.png)

쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일로 
사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 
종료되어도 인증이 유지된다는 특징이 있다.         
즉, 쿠키는 클라이언트의 상태정보를 로컬에 저장했다가 참조한다.             
Response Header에 Set-Cookie속성을 사용하면 클라이언트에 쿠키를 만들 수 있고 
쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 
넣어서 자동으로 서버에 전송한다.
- 이름: 각각의 쿠키를 구별하는데 사용되는 이름
- 값: 쿠키의 이름과 관련된 값
- 유효시간: 쿠키의 유지시간
- 도메인: 쿠키를 전송할 도메인
- 경로: 쿠키를 전송할 요청 경로

1. 클라이언트가 페이지를 요청
2. 서버에서 쿠키를 생성
3. HTTP 헤더에 쿠키를 포함시켜 응답
4. 브라우저가 종료되어도 쿠키 만료 기간이 있다면 클라이언트에서 보관하고 있음
5. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄
6. 서버에서 쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 
하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답

## 세션
세션은 쿠키를 기반하고 있지만 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 
세션은 서버 측에서 관리하는데 서버에서는 클라이언트를 구분하기 위해 세션 ID를 
부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지한다.             
(접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능하다.)               
사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 
서버 메모리를 많이 차지하게 되어 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 
되어 성능저하의 요인이 된다.              
클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 
부여하는데 이것이 세션 ID이다.
- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

1. 클라이언트가 서버에 접속 시 세션 ID를 발급받음
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있음
3. 클라이언트는 서버에 요청할 때 이 쿠키의 세션 ID를 같이 서버에 전달해서 요청
4. 서버는 세션 ID를 전달받아서 별다른 작업없이 세션 ID로 세션에 있는 클라이언트 
정보를 가져와서 사용
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답

## 쿠키와 세션의 차이
- 세션도 쿠키를 사용하기 때문에 쿠키와 세션은 비슷한 역할을 하고 동작원리도 비슷하다.
- 쿠키는 서버의 자원을 전혀 사용하지 않으며 세션은 서버의 자원을 이용하여 사용자의 정보가 저장되는 위치가 다르다.
- 세션은 서버의 처리가 필요하기 때문에 보안면에서 세션이 더 우수하고 요청 속도는 
쿠키가 세션보다 더 빠르다.
- 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 
- 쿠키도 만료시간이 있지만 파일로 저장이 되기 때문에 브라우저를 종료해도 계속해서 
정보가 남아있을 수 있지만 세션도 만료기간을 정할 수 있지만 브라우저가 종료되면 
만료시간에 상관없이 삭제된다.
- 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 
때문에 처리가 요구되어 비교적 느린 속도를 가진다.

## ajax
웹페이지에서 back단으로 갔다 왔을 때 다시 페이지가 로드되는 현상인 동기 현상 없이 
바로 통신가능한 비동기 통신이다.            
->통신을 하지만 새로 페이지가 로드되는 방식이 아닌 ajax 요청을 한 데이터만 가져와서 
그 부분에 적용하는 방식이다.
- type : "GET" OR "POST" 두가지를 사용할 수 있다.
- url : "/test/home" 통신을 원하는 url를 적어준다
- dataType : 넘길 데이터 타입
- contentType : 설정할 contentType
- data : 통신할 데이터를 넣는 부분
- success : 정상적으로 통신 했을때 함수를 하나 만들어 성공 처리를 한다.
- error : 결과가 정상적이지 않을때 함수를 하나 만들어 처리를 한다.
